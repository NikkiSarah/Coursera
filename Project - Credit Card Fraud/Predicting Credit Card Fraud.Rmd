---
title: "Predicting Credit Card Fraud"
output:
  html_document:
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Task 1: Project Objective
* The objective of this project is to predict which credit card transactions in the dataset are fraudulent using three classification algorithms and three synthetic balancing techniques. The three classifier algorithms we will train include:
  + Decision Tree, which uses a tree-like model of decisions to arrive at a classification prediction.
  + Naive Bayes, which uses Bayes' theorem to use probability to arrive at a classification prediction.
  + Linear Discriminant Analysis, which finds a linear combination of features that is then used to separate the classes and arrive at a classification prediction.

* Given that the objective is to evaluate the model performance of the three classifier algorithms and synthetic balancing techniques, we will not be thoroughly reviewing the model output, but rather will be focusing on the classification performance results.

* Lets start by loading the R library packages that will be used in this project, which are the caret, corrplot, and smotefamily packages.

```{r, echo=TRUE, results='hide'}
#Load the packages used in the project
install.packages("smotefamily", method = "wininet")
install.packages("naivebayes", method = "wininet")

library(caret)
library(corrplot)
library(smotefamily)
```

### Task 1.1: Import the dataset from Dropbox

Next, using the "read.csv" function, we will import the credit card fraud dataset and set the class to a factor. This dataset is a subset of the dataset from sourced from https://www.kaggle.com/mlg-ulb/creditcardfraud, which includes anonymized credit card transactions.

```{r}
#A. Load the dataset
creditcardFraud <- read.csv("creditcardFraud.csv")

#B. Change class to factor the as.factor function encodes the vector as a factor or category
creditcardFraud$class <- as.factor(creditcardFraud$class)
```

## Task 2: Explore The Data

* Now that we have downloaded the data we can start the training of the models, but it is important that we first understand and explore our data as it helps us identify potential data quality issues and it provides us the needed context to develop an appropriate model.  

* In this project, we will briefly explore the data and perform a high-level exploratory data analysis (EDA) of the dataset

```{r}
#A. Structure of the dataset
str(creditcardFraud)

#B. Missing data?
sum(is.na(creditcardFraud))

#C. Check the imbalance in the dataset
summary(creditcardFraud$class)
prop.table(table(creditcardFraud$class))

#D. Compile histograms for each variable
par(mfrow = c(3,5)) #Change setting to view 3x5 charts
i <- 1
for (i in 1:30) 
{hist((creditcardFraud[,i]), main = paste("Distibution of ", colnames(creditcardFraud[i])), xlab = colnames(creditcardFraud[i]), col = "light blue")
}

#E. Compute the correlations among the variables
par(mfrow = c(1,1))
cor_mat <- cor(creditcardFraud[, 1:30])
corrplot(cor_mat, type = "lower", tl.col = "black", tl.srt = 15)
```

## Task 3: Split the Data into Training and Test Sets

It is important that when we evaluate the performance of a model, we do so on a dataset that the model has not previously seen. Therefore, we will split our dataset into a training dataset and a test dataset and to maintain the same level of imbalance as in the original dataset, we will use stratified sampling by "class."

* Training Dataset: This is the random subset of your data used to initially fit (or train) your model.

* Test Dataset: This dataset used to provide an unbiased evaluation of the model fit on the training dataset.

```{r}
#A. Split data into training and testing dataset used for model building (training dataset) 
set.seed(1337)

train <- createDataPartition(creditcardFraud$class, p = 0.7, list = FALSE)
train_orig <- creditcardFraud[train, ]
test <- creditcardFraud[-train, ]

#B. Check the proportion of observations allocated to each group
dim(train_orig)[1]/dim(creditcardFraud)[1]
dim(test)[1]/dim(creditcardFraud)[1]

#C. Class balance for training dataset
prop.table(table(train_orig$class))

#D. Class balance for test dataset
prop.table(table(test$class))
```

## Task 4: Compile Synthetically Balanced Training Datsets

Now that we have split our dataset into a training and test dataset, lets create three new synthetically balanced datasets from the one imbalanced training dataset. To do this we will be using the "smotefamily" R package and we will be trying out three different techniques: SMOTE, ADASYN, and DB-SMOTE. Below is a brief description of each:

* SMOTE (Synthetic Minority Oversampling Technique): A subset of data is taken from the minority class as an example. New synthetic similar examples are generated from the “feature space” rather than the “data space.”

* ADASYN (Adaptive Synthetic Sampling): A weighted distribution is used depending on each minority class according to their degree of learning difficulty. More synthetic observations are generated for some minority class instances that are more difficult to learn as compared to others 

* DB-SMOTE (Density Based SMOTE): This over-samples the minority class at the decision boundary and over-examines the region to maintain the majority class detection rate. These are more likely to be misclassified than those far from the border.

```{r, echo=TRUE, results='hide', include=TRUE}
#SMOTE Balanced
train_smote <- SMOTE(train_orig[, -31], train_orig$class)
train_smote <- train_smote$data
train_smote$class <- as.factor(train_smote$class)

#ADASYN Balanced
train_adasyn <- ADAS(train_orig[, -31], train_orig$class)
train_adasyn <- train_adasyn$data
train_adasyn$class <- as.factor(train_adasyn$class)

#Density based SMOTE
train_dbsmote <- DBSMOTE(train_orig[, -31], train_orig$class)
train_dbsmote <- train_dbsmote$data
train_dbsmote$class <- as.factor(train_dbsmote$class)
```

### Task 4.1: Evaluate Class distributions for Synthetic datasets

```{r}
#Class Distribution of SMOTE Balanced Dataset
prop.table(table(train_smote$class))

#Class Distribution of ADASYN Balanced Dataset
prop.table(table(train_adasyn$class))

#Class Distribution of DB SMOTE Balanced Dataset
prop.table(table(train_dbsmote$class))
```

## Task 5: Original Data: Train Decision Tree, Naive Bayes, and LDA Models

Now that we have our four training datasets; 

1. the original imbalanced training dataset, 

2. the SMOTE balanced training dataset, 

3. the ADASYN balanced training dataset, and 

4. the DB-SMOTE balanced training dataset, 

We will use the 'caret' package to train three classifier models (decision tree, naive Bayes, linear discriminant analysis). Lets start by fitting the three classifier models using the original imbalanced training dataset.  We will use repeated 10x cross validation for our models across all of our trained models.

```{r}
#A. Global options that we will use across all of our trained models
ctrl <- trainControl(method = "cv", 
                     number = 10, 
                     classProbs = TRUE, 
                     summaryFunction = twoClassSummary)

#B. Decision Tree: original data
dt_orig <- train(class ~., data = train_orig, method = "rpart", trControl = ctrl,
                 metric = "ROC")

#C. Naive Bayes regression: original data
nb_orig <- train(class ~., data = train_orig, method = "naive_bayes", trControl = ctrl,
                 metric = "ROC")

#D. Linear Discriminant Analysis: original data
lda_orig <- train(class ~., data = train_orig, method = "lda", trControl = ctrl,
                  metric = "ROC")
```

### Task 5.1: Compile Classifications on Test Data using models trained on the original imbalanced training dataset

Next, we will use the models we have trained using the original imbalanced training dataset to generate predictions on the test dataset. 

* We will then compile three measures of performance, which we will use to compare the performance of the models across all of our trained models: 
  + Precision = TP / (TP+FP) - measures proportion of positive cases that are truly positive
  + Recall = TP / (TP+FN) - measures how complete the results are. This is often also called the senSitivity
  + F1 measure = (2xPrecision*Recall)/(Recall+Precision) - this combines the precision and recall into a single number
  
```{r}
###################################################
#Decision Tree Model - Trained on original dataset#
###################################################
#A. Decision Tree Model predictions
dt_orig_pred <- predict(dt_orig, newdata = test, type = "prob")

#B. Decision Tree - Assign class to probabilities
dt_orig_test <- factor(ifelse(dt_orig_pred$yes > 0.5, "yes", "no"))

#C. Decision Tree Save Precision/Recall/F
dt_orig_precision <- posPredValue(dt_orig_test, test$class, positive = "yes")
dt_orig_recall <- sensitivity(dt_orig_test, test$class, positive = "yes")
dt_orig_F1 <- (2*dt_orig_precision*dt_orig_recall)/(dt_orig_precision + dt_orig_recall)

#################################################
#Naive Bayes Model - Trained on original dataset#
#################################################
#A. NB Model predictions
nb_orig_pred <- predict(nb_orig, newdata = test, type = "prob")

#B. NB - Assign class to probabilities
nb_orig_test <- factor(ifelse(nb_orig_pred$yes > 0.5, "yes", "no"))

#C. NB Save Precision/Recall/F
nb_orig_precision <- posPredValue(nb_orig_test, test$class, positive = "yes")
nb_orig_recall <- sensitivity(nb_orig_test, test$class, positive = "yes")
nb_orig_F1 <- (2*nb_orig_precision*nb_orig_recall)/(nb_orig_precision + nb_orig_recall)

#########################################
#LDA Model - Trained on original dataset#
#########################################
#A. LDA Model predictions
lda_orig_pred <- predict(lda_orig, newdata = test, type = "prob")

#B. LDA - Assign class to probabilities
lda_orig_test <- factor(ifelse(lda_orig_pred$yes > 0.5, "yes", "no"))

#C. LDA Save Precision/Recall/F
lda_orig_precision <- posPredValue(lda_orig_test, test$class, positive = "yes")
lda_orig_recall <- sensitivity(lda_orig_test, test$class, positive = "yes")
lda_orig_F1 <- (2*lda_orig_precision*lda_orig_recall)/(lda_orig_precision + lda_orig_recall)
```

## Task 6: SMOTE Balanced Data: Train Decision Tree, Naive Bayes, and LDA Models

Next, We will train the three classifier models using the SMOTE balanced training dataset. To train the models, we can simply copy and paste the code we used to train the models in task 5, create new names for the models and change the data we are using to train our models using from 'train_orig' to the  'train_smote' dataset.

```{r}
#A. Decision Tree: SMOTE data
dt_smote <- train(class ~., data = train_smote, method = "rpart", trControl = ctrl,
                 metric = "ROC")

#B. Naive Bayes regression: SMOTE data
nb_smote <- train(class ~., data = train_smote, method = "naive_bayes", trControl = ctrl,
                 metric = "ROC")

#C. Linear Discriminant Analysis: SMOTE data
lda_smote <- train(class ~., data = train_smote, method = "lda", trControl = ctrl,
                  metric = "ROC")
```

### Task 6.1: Compile predictions using models trained on the SMOTE balanced training dataset

Next, we will use the models we have trained using the SMOTE balanced training dataset to generate predictions on the test dataset, and we will compute our three performance measures. To complete this, we can copy the code from the earlier task and change the names of the output and models to reference the models trained using the SMOTE balanced training dataset.

```{r}
###################################################
#Decision Tree Model - Trained on SMOTE dataset#
###################################################
#A. Decision Tree Model predictions
dt_smote_pred <- predict(dt_smote, newdata = test, type = "prob")

#B. Decision Tree - Assign class to probabilities
dt_smote_test <- factor(ifelse(dt_smote_pred$yes > 0.5, "yes", "no"))

#C. Decision Tree Save Precision/Recall/F
dt_smote_precision <- posPredValue(dt_smote_test, test$class, positive = "yes")
dt_smote_recall <- sensitivity(dt_smote_test, test$class, positive = "yes")
dt_smote_F1 <- (2*dt_smote_precision*dt_smote_recall)/(dt_smote_precision + dt_smote_recall)

#################################################
#Naive Bayes Model - Trained on SMOTE dataset#
#################################################
#A. NB Model predictions
nb_smote_pred <- predict(nb_smote, newdata = test, type = "prob")

#B. NB - Assign class to probabilities
nb_smote_test <- factor(ifelse(nb_smote_pred$yes > 0.5, "yes", "no"))

#C. NB Save Precision/Recall/F
nb_smote_precision <- posPredValue(nb_smote_test, test$class, positive = "yes")
nb_smote_recall <- sensitivity(nb_smote_test, test$class, positive = "yes")
nb_smote_F1 <- (2*nb_smote_precision*nb_smote_recall)/(nb_smote_precision + nb_smote_recall)

#########################################
#LDA Model - Trained on SMOTE dataset#
#########################################
#A. LDA Model predictions
lda_smote_pred <- predict(lda_smote, newdata = test, type = "prob")

#B. LDA - Assign class to probabilities
lda_smote_test <- factor(ifelse(lda_smote_pred$yes > 0.5, "yes", "no"))

#C. LDA Save Precision/Recall/F
lda_smote_precision <- posPredValue(lda_smote_test, test$class, positive = "yes")
lda_smote_recall <- sensitivity(lda_smote_test, test$class, positive = "yes")
lda_smote_F1 <- (2*lda_smote_precision*lda_smote_recall)/(lda_smote_precision + lda_smote_recall)
```

## Task 7: ADASYN Balanced Data: Train Decision Tree, Naive Bayes, and LDA Models

In task 7, we will train the three classifier models using the ADASYN balanced training dataset. Again, to train the models, we can simply copy and paste the code we used to train the models in task 6, create new names for the model and change the data we are using to train our model to 'train_adasyn'

```{r}
#A. Decision Tree: ADASYN data
dt_adasyn <- train(class ~., data = train_adasyn, method = "rpart", trControl = ctrl,
                 metric = "ROC")

#B. Naive Bayes regression: ADASYN data
nb_adasyn <- train(class ~., data = train_adasyn, method = "naive_bayes", trControl = ctrl,
                 metric = "ROC")

#C. Linear Discriminant Analysis: ADASYN data
lda_adasyn <- train(class ~., data = train_adasyn, method = "lda", trControl = ctrl,
                  metric = "ROC")
```

### Task 7.1: Compile predictions using models trained on the ADASYN balanced training dataset

Next, we will use the models we have trained using the ADASYN balanced training dataset to generate predictions on the test dataset, and we will compute our three performance measures. To complete this, we can copy the code from the earlier task and change the names of the output and models to reference the models trained using the SMOTE balanced training dataset.

```{r}
###################################################
#Decision Tree Model - Trained on ADASYN dataset#
###################################################
#A. Decision Tree Model predictions
dt_adasyn_pred <- predict(dt_adasyn, newdata = test, type = "prob")

#B. Decision Tree - Assign class to probabilities
dt_adasyn_test <- factor(ifelse(dt_adasyn_pred$yes > 0.5, "yes", "no"))

#C. Decision Tree Save Precision/Recall/F
dt_adasyn_precision <- posPredValue(dt_adasyn_test, test$class, positive = "yes")
dt_adasyn_recall <- sensitivity(dt_adasyn_test, test$class, positive = "yes")
dt_adasyn_F1 <- (2*dt_adasyn_precision*dt_adasyn_recall)/(dt_adasyn_precision + dt_adasyn_recall)

#################################################
#Naive Bayes Model - Trained on ADASYN dataset#
#################################################
#A. NB Model predictions
nb_adasyn_pred <- predict(nb_adasyn, newdata = test, type = "prob")

#B. NB - Assign class to probabilities
nb_adasyn_test <- factor(ifelse(nb_adasyn_pred$yes > 0.5, "yes", "no"))

#C. NB Save Precision/Recall/F
nb_adasyn_precision <- posPredValue(nb_adasyn_test, test$class, positive = "yes")
nb_adasyn_recall <- sensitivity(nb_adasyn_test, test$class, positive = "yes")
nb_adasyn_F1 <- (2*nb_adasyn_precision*nb_adasyn_recall)/(nb_adasyn_precision + nb_adasyn_recall)

#########################################
#LDA Model - Trained on ADASYN dataset#
#########################################
#A. LDA Model predictions
lda_adasyn_pred <- predict(lda_adasyn, newdata = test, type = "prob")

#B. LDA - Assign class to probabilities
lda_adasyn_test <- factor(ifelse(lda_adasyn_pred$yes > 0.5, "yes", "no"))

#C. LDA Save Precision/Recall/F
lda_adasyn_precision <- posPredValue(lda_adasyn_test, test$class, positive = "yes")
lda_adasyn_recall <- sensitivity(lda_adasyn_test, test$class, positive = "yes")
lda_adasyn_F1 <- (2*lda_adasyn_precision*lda_adasyn_recall)/(lda_adasyn_precision + lda_adasyn_recall)
```

## Task 8: DB-SMOTE Balanced Data: Train Decision Tree, Naive Bayes, and LDA Models

In task 8, we will train the three classifier models using the DB-SMOTE balanced training dataset. To train the models, we can simply copy and paste the code we used to train the models in task 7, create new names for the model and change the data we are using to train our model to 'train_dbsmote'

```{r}
#A. Decision Tree: DBSMOTE data
dt_dbsmote <- train(class ~., data = train_dbsmote, method = "rpart", trControl = ctrl,
                 metric = "ROC")

#B. Naive Bayes regression: DBSMOTE data
nb_dbsmote <- train(class ~., data = train_dbsmote, method = "naive_bayes", trControl = ctrl,
                 metric = "ROC")

#C. Linear Discriminant Analysis: DBSMOTE data
lda_dbsmote <- train(class ~., data = train_dbsmote, method = "lda", trControl = ctrl,
                  metric = "ROC")
```

### Task 8.1: Compile predictions using models trained on the DB SMOTE balanced training dataset

Next, we will use the models we have trained using the DB-SMOTE balanced training dataset to generate predictions on the test dataset, and we will compute our three performance measures. To complete this, we can copy the code from the earlier task and change the names of the output and models to reference the models trained using the DB-SMOTE balanced training dataset.

```{r}
###################################################
#Decision Tree Model - Trained on DBSMOTE dataset#
###################################################
#A. Decision Tree Model predictions
dt_dbsmote_pred <- predict(dt_dbsmote, newdata = test, type = "prob")

#B. Decision Tree - Assign class to probabilities
dt_dbsmote_test <- factor(ifelse(dt_dbsmote_pred$yes > 0.5, "yes", "no"))

#C. Decision Tree Save Precision/Recall/F
dt_dbsmote_precision <- posPredValue(dt_dbsmote_test, test$class, positive = "yes")
dt_dbsmote_recall <- sensitivity(dt_dbsmote_test, test$class, positive = "yes")
dt_dbsmote_F1 <- (2*dt_dbsmote_precision*dt_dbsmote_recall)/(dt_dbsmote_precision + dt_dbsmote_recall)

#################################################
#Naive Bayes Model - Trained on DBSMOTE dataset#
#################################################
#A. NB Model predictions
nb_dbsmote_pred <- predict(nb_dbsmote, newdata = test, type = "prob")

#B. NB - Assign class to probabilities
nb_dbsmote_test <- factor(ifelse(nb_dbsmote_pred$yes > 0.5, "yes", "no"))

#C. NB Save Precision/Recall/F
nb_dbsmote_precision <- posPredValue(nb_dbsmote_test, test$class, positive = "yes")
nb_dbsmote_recall <- sensitivity(nb_dbsmote_test, test$class, positive = "yes")
nb_dbsmote_F1 <- (2*nb_dbsmote_precision*nb_dbsmote_recall)/(nb_dbsmote_precision + nb_dbsmote_recall)

#########################################
#LDA Model - Trained on DBSMOTE dataset#
#########################################
#A. LDA Model predictions
lda_dbsmote_pred <- predict(lda_dbsmote, newdata = test, type = "prob")

#B. LDA - Assign class to probabilities
lda_dbsmote_test <- factor(ifelse(lda_dbsmote_pred$yes > 0.5, "yes", "no"))

#C. LDA Save Precision/Recall/F
lda_dbsmote_precision <- posPredValue(lda_dbsmote_test, test$class, positive = "yes")
lda_dbsmote_recall <- sensitivity(lda_dbsmote_test, test$class, positive = "yes")
lda_dbsmote_F1 <- (2*lda_dbsmote_precision*lda_dbsmote_recall)/(lda_dbsmote_precision + lda_dbsmote_recall)
```

## Task 9: Compare the model performance 

We will compare the recall, precision, and F1 performance measures for each of the three models we trained using the four training datasets: 

1. original imbalanced, 
2. SMOTE balanced, 
3. ADASYN balanced, and 
4. DB SMOTE balanced. 

Recall that the most important performance measure for the fraud problem is the recall, which measures how complete our results are indicating the model captures more of the fraudulent transactions.

```{r}
#Lets reset the chart settings so we see one chart at a time
par(mfrow = c(1,1))

#Compare the Recall of the models: TP / TP + FN. To do that, we'll need to
# combine our results into a dataframe
model_compare_recall <- data.frame(
  Model = c(
    'DT-Orig',
    'NB-Orig',
    'LDA-Orig',
    'DT-SMOTE',
    'NB-SMOTE',
    'LDA-SMOTE',
    'DT-ADASYN',
    'NB-ADASYN',
    'LDA-ADASYN',
    'DT-DBSMOTE',
    'NB-DBSMOTE',
    'LDA-DBSMOTE'
  ),
  Recall = c(
    dt_orig_recall,
    nb_orig_recall,
    lda_orig_recall,
    dt_smote_recall,
    nb_smote_recall,
    lda_smote_recall,
    dt_adasyn_recall,
    nb_adasyn_recall,
    lda_adasyn_recall,
    dt_dbsmote_recall,
    nb_dbsmote_recall,
    lda_dbsmote_recall
  )
)

ggplot(aes(x = reorder(Model, -Recall) , y = Recall), data = model_compare_recall) +
  geom_bar(stat = 'identity', fill = 'light blue') +
  ggtitle('Comparative Recall of Models on Test Data') +
  xlab('Models')  +
  ylab('Recall Measure') +
  geom_text(aes(label = round(Recall, 2))) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 40))

#Compare the Precision of the models: TP/TP+FP
model_compare_precision <- data.frame(
  Model = c(
    'DT-Orig',
    'NB-Orig',
    'LDA-Orig',
    'DT-SMOTE',
    'NB-SMOTE',
    'LDA-SMOTE',
    'DT-ADASYN',
    'NB-ADASYN',
    'LDA-ADASYN',
    'DT-DBSMOTE',
    'NB-DBSMOTE',
    'LDA-DBSMOTE'
  ),
  Precision = c(
    dt_orig_precision,
    nb_orig_precision,
    lda_orig_precision,
    dt_smote_precision,
    nb_smote_precision,
    lda_smote_precision,
    dt_adasyn_precision,
    nb_adasyn_precision,
    lda_adasyn_precision,
    dt_dbsmote_precision,
    nb_dbsmote_precision,
    lda_dbsmote_precision
  )
)

ggplot(aes(x = reorder(Model, -Precision) , y = Precision), data = model_compare_precision) +
  geom_bar(stat = 'identity', fill = 'light green') +
  ggtitle('Comparative Precision of Models on Test Data') +
  xlab('Models')  +
  ylab('Precision Measure') +
  geom_text(aes(label = round(Precision, 2))) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 40))

#Compare the F1 of the models: 2*((Precision*Recall) / (Precision + Recall))
model_compare_f1 <- data.frame(
  Model = c(
    'DT-Orig',
    'NB-Orig',
    'LDA-Orig',
    'DT-SMOTE',
    'NB-SMOTE',
    'LDA-SMOTE',
    'DT-ADASYN',
    'NB-ADASYN',
    'LDA-ADASYN',
    'DT-DBSMOTE',
    'NB-DBSMOTE',
    'LDA-DBSMOTE'
  ),
  F1 = c(
    dt_orig_F1,
    nb_orig_F1,
    lda_orig_F1,
    dt_smote_F1,
    nb_smote_F1,
    lda_smote_F1,
    dt_adasyn_F1,
    nb_adasyn_F1,
    lda_adasyn_F1,
    dt_dbsmote_F1,
    nb_dbsmote_F1,
    lda_dbsmote_F1
  )
)

ggplot(aes(x = reorder(Model, -F1) , y = F1), data = model_compare_f1) +
  geom_bar(stat = 'identity', fill = 'light grey') +
  ggtitle('Comparative F1 of Models on Test Data') +
  xlab('Models')  +
  ylab('F1 Measure') +
  geom_text(aes(label = round(F1, 2))) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 40))
```

